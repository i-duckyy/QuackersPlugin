/*
    Copyright - Quackers Plugin 2025
    This file is part of the Quackers Plugin project.
    Unauthorized use, distribution, or modification of this file without explicit permission is strictly prohibited and may be subject to DMCA takedown actions.
*/

package com.quackers.plugin.modules.exploits;

import com.quackers.plugin.QuackersPlugin;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.util.math.Vec3d;

import java.util.*;

public class FourjjBCoordExploit extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();

    private final Setting<Boolean> strongPackets = sgGeneral.add(new BoolSetting.Builder()
        .name("strong-packets")
        .description("Makes it easier to find the players by reloading chunks on drop.")
        .defaultValue(true)
        .build()
    );

    private final Setting<Boolean> reloadChunksOnDrop = sgGeneral.add(new BoolSetting.Builder()
        .name("reload-chunks-on-drop")
        .description("Reload chunks when dropping items.")
        .defaultValue(true)
        .build()
    );

    private final Setting<Integer> dropInterval = sgGeneral.add(new IntSetting.Builder()
        .name("drop-interval")
        .description("Ticks between each drop action.")
        .defaultValue(20)
        .min(1)
        .max(200)
        .sliderRange(1, 100)
        .build()
    );

    private final Setting<PacketType> rightCollisionAction = sgGeneral.add(new EnumSetting.Builder<PacketType>()
        .name("packet-type")
        .description("What type of packet is used")
        .defaultValue(PacketType.FourjjB)
        .build()
    );

    private final Setting<List<String>> playerWhitelist = sgGeneral.add(new StringListSetting.Builder()
        .name("player-whitelist")
        .description("Only log players in this list. Empty means log all.")
        .defaultValue(Collections.emptyList())
        .build()
    );

    private final Setting<List<String>> playerBlacklist = sgGeneral.add(new StringListSetting.Builder()
        .name("player-blacklist")
        .description("Do not log players in this list.")
        .defaultValue(Collections.emptyList())
        .build()
    );

    private final Setting<Double> logRadius = sgGeneral.add(new DoubleSetting.Builder()
        .name("log-radius")
        .description("Only log players within this radius. 0 or less disables radius filtering.")
        .defaultValue(0.0)
        .min(0)
        .max(1000)
        .sliderRange(0, 100)
        .build()
    );

    private final Setting<Double> spoofOffsetRange = sgGeneral.add(new DoubleSetting.Builder()
        .name("spoof-offset-range")
        .description("Range of random offset added to logged player positions when not accurate.")
        .defaultValue(1.5)
        .min(0)
        .max(10)
        .sliderRange(0, 5)
        .build()
    );

    private final Setting<Boolean> randomizeDropSlot = sgGeneral.add(new BoolSetting.Builder()
        .name("randomize-drop-slot")
        .description("Randomize which hotbar slot to drop from instead of first found.")
        .defaultValue(false)
        .build()
    );

    private final Setting<Boolean> dropAnyItem = sgGeneral.add(new BoolSetting.Builder()
        .name("drop-any-item")
        .description("Drop any item found instead of only obsidian when using FourjjB packet type.")
        .defaultValue(false)
        .build()
    );

    private final Setting<Boolean> notifyOnDrop = sgGeneral.add(new BoolSetting.Builder()
        .name("notify-on-drop")
        .description("Send a chat notification when an item is dropped.")
        .defaultValue(true)
        .build()
    );

    private enum PacketType {
        Global,
        FourjjB
    }

    private int tickCounter = 0;
    private final Random random = new Random();

    public FourjjBCoordExploit() {
        super(QuackersPlugin.Exploit, "4jjB-coordinate-exploit", "Drops items and logs player positions with spoofing logic.");
    }

    @Override
    public void onActivate() {
        tickCounter = 0;
    }

    @EventHandler
    private void onTick(TickEvent.Post event) {
        tickCounter++;
        if (tickCounter < dropInterval.get()) return;
        tickCounter = 0;

        switch (rightCollisionAction.get()) {
            case Global -> dropAnyItemWithLogs();
            case FourjjB -> dropConfiguredItemOrDisableWithLogs();
        }
    }

    private void dropAnyItemWithLogs() {
        List<Integer> slots = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            assert mc.player != null;
            if (!mc.player.getInventory().getStack(i).isEmpty()) {
                slots.add(i);
            }
        }
        if (slots.isEmpty()) {
            info("[4jjB] No items in hotbar to drop. Disabling module.");
            toggle();
            return;
        }

        int slot = randomizeDropSlot.get() ? slots.get(random.nextInt(slots.size())) : slots.getFirst();

        mc.player.getInventory().selectedSlot = slot;
        mc.player.dropSelectedItem(false);

        if (strongPackets.get() && reloadChunksOnDrop.get()) reloadChunks();

        logDropAndPlayers(false);
        if (notifyOnDrop.get()) info("[4jjB] Dropped item from slot " + slot);
    }

    private void dropConfiguredItemOrDisableWithLogs() {
        Item targetItem = dropAnyItem.get() ? null : Items.OBSIDIAN;

        List<Integer> candidateSlots = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            assert mc.player != null;
            ItemStack stack = mc.player.getInventory().getStack(i);
            if (!stack.isEmpty() && (targetItem == null || stack.getItem() == targetItem)) {
                candidateSlots.add(i);
            }
        }

        if (candidateSlots.isEmpty()) {
            info("[4jjB] No " + (targetItem == null ? "items" : targetItem.getName().getString()) + " in hotbar. Disabling module.");
            toggle();
            return;
        }

        int slot = randomizeDropSlot.get() ? candidateSlots.get(random.nextInt(candidateSlots.size())) : candidateSlots.getFirst();
        mc.player.getInventory().selectedSlot = slot;
        mc.player.dropSelectedItem(false);

        if (strongPackets.get() && reloadChunksOnDrop.get()) reloadChunks();

        logDropAndPlayers(true);
        if (notifyOnDrop.get()) info("[4jjB] Dropped " + (targetItem == null ? "item" : targetItem.getName().getString()) + " from slot " + slot);
    }

    private void logDropAndPlayers(boolean accurate) {
        assert mc.player != null;
        Vec3d playerPos = mc.player.getPos();
        Vec3d dropPos = playerPos.subtract(0, 1.0, 0);

        info("[4jjB] Dropped item at: %.2f, %.2f, %.2f".formatted(dropPos.x, dropPos.y, dropPos.z));

        List<String> whitelist = playerWhitelist.get().stream().map(String::toLowerCase).toList();
        List<String> blacklist = playerBlacklist.get().stream().map(String::toLowerCase).toList();

        assert mc.world != null;
        for (PlayerEntity player : mc.world.getPlayers()) {
            if (player == mc.player) continue;

            String playerName = player.getName().getString();
            String playerNameLower = playerName.toLowerCase();

            if (!whitelist.isEmpty() && !whitelist.contains(playerNameLower)) continue;
            if (blacklist.contains(playerNameLower)) continue;

            Vec3d pos = player.getPos();
            double dist = playerPos.distanceTo(pos);

            if (logRadius.get() > 0 && dist > logRadius.get()) continue;

            if (!accurate) {
                pos = pos.add(randomOffset(), randomOffset(), randomOffset());
            }

            info("[4jjB] Player %s at: %.2f, %.2f, %.2f (%.2f blocks away)".formatted(playerName, pos.x, pos.y, pos.z, dist));
        }
    }

    private double randomOffset() {
        return random.nextDouble() * spoofOffsetRange.get() * 2 - spoofOffsetRange.get();
    }

    private void reloadChunks() {
        mc.worldRenderer.reload();
    }
}
