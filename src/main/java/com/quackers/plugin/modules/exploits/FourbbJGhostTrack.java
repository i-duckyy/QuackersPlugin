package com.quackers.plugin.modules.exploits;

import com.quackers.plugin.QuackersPlugin;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;

import java.util.*;

public class FourbbJGhostTrack extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();

    private final Setting<Boolean> guesserEnabled = sgGeneral.add(new BoolSetting.Builder()
        .name("enable-guesser")
        .description("Enable guessing of player positions when they are not visible.")
        .defaultValue(false)
        .build()
    );

    private final Setting<Double> guessRadiusMultiplier = sgGeneral.add(new DoubleSetting.Builder()
        .name("guess-radius-accuracy")
        .description("Accuracy for the fuzz radius when guessing player positions.")
        .defaultValue(0.1)
        .min(0.01)
        .max(1)
        .sliderRange(0.01, 0.5)
        .build()
    );

    private final Setting<Boolean> notifyOnReappear = sgGeneral.add(new BoolSetting.Builder()
        .name("notify-on-reappear")
        .description("Notify when a ghost player reappears.")
        .defaultValue(true)
        .build()
    );

    private final Setting<Boolean> logExactPositions = sgGeneral.add(new BoolSetting.Builder()
        .name("log-exact-positions")
        .description("Log exact positions of visible players.")
        .defaultValue(true)
        .build()
    );

    private final Setting<Boolean> logGuesses = sgGeneral.add(new BoolSetting.Builder()
        .name("log-guesses")
        .description("Log guessed positions for ghost players.")
        .defaultValue(true)
        .build()
    );

    private final Map<String, GhostPlayer> tracked = new HashMap<>();
    private final Random rand = new Random();
    private int tickCounter = 0;

    public FourbbJGhostTrack() {
        super(QuackersPlugin.Exploit, "4bbJ-ghost-track", "Passive player tracking based on last known positions.");
    }

    private static class GhostPlayer {
        Vec3d lastSeen;
        Vec3d lastLastSeen;
        int ticksSinceSeen;
        boolean wasVisibleLastTick = true;

        GhostPlayer(Vec3d pos) {
            this.lastSeen = pos;
            this.lastLastSeen = pos;
            this.ticksSinceSeen = 0;
        }

        void update(Vec3d newPos) {
            this.lastLastSeen = this.lastSeen;
            this.lastSeen = newPos;
            this.ticksSinceSeen = 0;
            wasVisibleLastTick = true;
        }

        void tick() {
            ticksSinceSeen++;
            wasVisibleLastTick = false;
        }

        Vec3d getVelocity() {
            return lastSeen.subtract(lastLastSeen);
        }

        Vec3d getFuzzedPosition(Random rand, double multiplier) {
            Vec3d velocity = getVelocity();

            Vec3d predictedPos = lastSeen.add(velocity);

            double fuzzAmount = ticksSinceSeen * multiplier;
            double dx = (rand.nextDouble() - 0.5) * fuzzAmount;
            double dy = (rand.nextDouble() - 0.5) * fuzzAmount * 0.5;
            double dz = (rand.nextDouble() - 0.5) * fuzzAmount;

            return predictedPos.add(dx, dy, dz);
        }
    }

    @Override
    public void onActivate() {
        tracked.clear();
        tickCounter = 0;
    }

    @EventHandler
    private void onTick(TickEvent.Post event) {
        tickCounter++;

        Set<String> currentlyVisible = new HashSet<>();

        assert mc.world != null;
        for (PlayerEntity player : mc.world.getPlayers()) {
            if (player == mc.player) continue;
            String name = player.getName().getString();
            currentlyVisible.add(name);
            tracked.putIfAbsent(name, new GhostPlayer(player.getPos()));

            GhostPlayer ghost = tracked.get(name);
            ghost.update(player.getPos());

            if (!ghost.wasVisibleLastTick && notifyOnReappear.get()) {
                info("[4bbJ] Player %s reappeared at %.1f, %.1f, %.1f", name, player.getX(), player.getY(), player.getZ());
            }
        }

        Iterator<Map.Entry<String, GhostPlayer>> it = tracked.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, GhostPlayer> entry = it.next();
            String name = entry.getKey();
            GhostPlayer ghost = entry.getValue();

            if (!currentlyVisible.contains(name)) {
                ghost.tick();

                int MAX_TICKS_UNSEEN = 600;
                if (ghost.ticksSinceSeen > MAX_TICKS_UNSEEN) {
                    it.remove();
                }
            }
        }

        if (tickCounter >= 20) {
            tickCounter = 0;

            tracked.forEach((name, ghost) -> {
                if (currentlyVisible.contains(name)) {
                    if (logExactPositions.get()) {
                        Vec3d pos = ghost.lastSeen;
                        info("[4bbJ] Exact: %s at %.1f, %.1f, %.1f", name, pos.x, pos.y, pos.z);
                    }
                } else if (guesserEnabled.get() && ghost.ticksSinceSeen > 20) {
                    if (logGuesses.get()) {
                        Vec3d pos = ghost.getFuzzedPosition(rand, guessRadiusMultiplier.get());
                        info("[4bbJ] Guess: %s at ~ %.1f, %.1f, %.1f (ghosted %ds ago)",
                            name, pos.x, pos.y, pos.z, ghost.ticksSinceSeen / 20);
                    }
                }
            });
        }
    }
}
